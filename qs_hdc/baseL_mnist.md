# 像指纹识别一样认数字：MNIST 二进制超维计算 (HDC) 指南

这份文档将带你了解 `baseline_mnist.py` 背后的神奇原理。我们不使用传统的深度神经网络，而是使用一种叫做 **超维计算 (Hyperdimensional Computing, HDC)** 的技术来识别手写数字。

## 核心概念：把图像变成“长长的条形码”

想象一下，我们把每张 28x28 像素的数字图像，转换成一串非常非常长（比如 10,000 位）的由 0 和 1 组成的二进制代码。这个长代码就是我们所说的 **“超向量 (Hypervector)”**。

这个过程就像是给每张图片生成了一个独一无二的 **“数字指纹”**。

### 它是如何工作的？

整个过程可以分为三步：**编码 (Encoding)**、**训练 (Training)** 和 **预测 (Inference)**。

#### 1. 编码 (Encoding)：生成指纹
我们怎么把一张图片变成 10,000 位的 0/1 代码呢？
- **随机投影 (Random Projection)**：想象我们要通过 10,000 个不同的“随机滤镜”来观察这张图片。
- **二值化 (Binarization)**：如果某个滤镜看到的特征比较强，我们就记为 `1`，否则记为 `0`。
- **结果**：原本复杂的图片，现在变成了一串 10,000 位的二进制序列。

**代码对应：** `Classifier.encode` 方法
- `x - 0.5`: 把图片数据归一化，方便处理。
- `projection(x)`: 应用随机滤镜（这里我们优化成了只用加减法的硬件友好模式）。
- `sample_hv > 0`: 生成 0/1 代码。

#### 2. 训练 (Training)：记住特征
电脑怎么知道“0”长什么样，“1”长什么样？
- 我们把所有属于“0”的图片的指纹（二进制代码）收集起来。
- **多数投票 (Majority Vote)**：如果在某个位置上，大多数图片的指纹都是 `1`，那么“0”这个类别的标准指纹在这个位置也是 `1`。
- 这样，我们就为 0 到 9 这十个数字，各生成了一个 **“标准指纹” (Centroid)**。

**代码对应：** `Classifier.fit` 方法
- `class_accumulators`: 一个记分牌，记录每个位置上出现 1 和 0 的次数（+1/-1）。
- `centroids = class_accumulators > 0`: 根据记分牌的结果，确定最终的标准指纹。

#### 3. 预测 (Inference)：找最像的
现在来了一张新图片，电脑怎么猜它是几？
- 第一步：先算出这张新图片的指纹。
- 第二步：把它和我们之前存好的 10 个“标准指纹”进行对比。
- **汉明距离 (Hamming Distance)**：比较两个指纹有多少位是相同的。
- **结果**：哪个标准指纹和它最像（相同位数最多），电脑就猜它是那个数字。

**代码对应：** `Classifier.forward` 和 `predict` 方法
- `torchhd.hamming_similarity`: 计算相似度，也就是数数有多少位是一样的。

## 为什么这么做？(优势)

1.  **简单高效**：大部分计算都是二进制操作（异或、计数），在硬件芯片（FPGA/ASIC）上运行速度极快且省电。
2.  **抗干扰**：因为指纹很长（10,000 位），即使坏掉了几百位，整体信息依然完整，依然能识别出来。这就好比全息图，撕掉一角还能看到全貌。
3.  **快速学习**：不需要像深度学习那样反复训练几百轮，通常扫一遍数据就能记住。

## 如何运行代码

确保你已经配置好了环境，在终端输入：

```bash
python qs_hdc/baseline_mnist.py
```

稍等片刻，你就能看到训练进度条，以及最终的测试准确率（大约 81% 左右）。

---
*这就好比我们不教电脑去理解笔画的弯曲，而是教它记住每一类数字独特的“长条形码”特征。简单，暴力，但有效！*
